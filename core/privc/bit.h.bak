// Copyright (c) 2020 PaddlePaddle Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <vector>
#include <limits>

#include "core/privc/privc_context.h"
#include "core/privc/crypto.h"
#include "core/privc/triplet_generator.h"
#include "core/privc/common.h"
#include "core/privc/ot.h"

namespace privc {

block garbled_and(block a, block b);

block garbled_share(bool val);

std::vector<block> garbled_share(int64_t val);

std::vector<block> garbled_share(const std::vector<int64_t>& val);

inline void if_than_else(TensorAdapter<bool>* val,
                         TensorBlock* than_val,
                         TensorBlock* else_val,
                         TensorBlock* ret) {
    block* than_val_ptr = reinterpret_cast<block*>(than_val->data());
    block* else_val_ptr = reinterpret_cast<block*>(else_val->data());
    block* ret_ptr = reinterpret_cast<block*>(ret->data());
    for (int i = 0; i < val->numel(); ++i) {
        *(ret_ptr + i) = *(val->data() + i) ? *(than_val_ptr + i) : *(else_val_ptr + i);
    }
}

// use alias name to distinguish TensorAdapter<block>
// and normal TensorAdapter<int64_t>
using TensorBlock = TensorAdapter<int64_t>;

class Bit {
public:
    // using double memory of TensorAdapter<int64_t> to present
    // TensorAdapter<block>
    std::shared_ptr<TensorBlock> _share;
    //block _share;

public:
    //Bit() : _share(ZeroBlock) {}
    Bit() = delete;
    Bit(std::vector<size_t> shape) {
        shape.insert(shape.begin(), 2);
        _share = tensor_factory()->create(shape);
        std::for_each(_share->data(), _share->data() + _share->numel(),
                      [](int64_t& a) { a = 0;});
    }

    Bit(bool val, size_t party_in) {
        if (party_in == 0) {
            if (party() == 0) {
                _share = privc_ctx()->gen_random_private<block>();
                block to_send = _share;
                if (val) {
                    to_send ^= ot()->garbled_delta();
                }
                net()->send(next_party(), to_send);

            } else {
                _share = net()->recv<block>(next_party());
            }
        } else {
            _share = garbled_share(val);
        }
    }

    Bit(TensorAdapter<bool>* val, size_t party_in) {
        auto block_shape = val->shape();
        block_shape.insert(block_shape.begin(), 2);
        if (party_in == 0) {
            if (party() == 0) {
                _share = tensor_factory()->create(block_shape);
                privc_ctx()->template gen_random_private(*_share);
                //block to_send = _share;
                //if (val) {
                //    to_send ^= ot()->garbled_delta();
                //}
                // to_send = val * to_send + (1 - val) * mask_to_send
                auto to_send = tensor_factory()->template create<int64_t>(block_shape);
                _share->copy(to_send.get());
                auto mask_to_send = tensor_factory()->template create<int64_t>(block_shape);
                auto garbled_delta = tensor_factory()->template create<int64_t>(block_shape);
                to_send->bitwise_xor(garbled_delta.get(), mask_to_send.get());
                if_than_else(val, mask_to_send.get(), to_send.get(), to_send.get());

                net()->send(next_party(), to_send);

            } else {
                // need to know recv shape
                _share = tensor_factory()->template create<int64_t>(block_shape);
                net()->recv<TensorBlock>(next_party(), *_share);
            }
        } else {
            garbled_share(val, _share.get());
        }
    }

    ~Bit() {}

    Bit operator^(const Bit &rhs) const {
        Bit ret;
        ret._share = _share ^ rhs._share;
        return ret;
    }
    void bitwise_xor(const Bit)

    block& share() {
      return _share;
    }

    const block& share() const {
      return _share;
    }

    Bit operator&(const Bit &rhs) const {
        Bit ret;
        ret._share = garbled_and(_share, rhs._share);
        return ret;
    }

    Bit operator|(const Bit &rhs) const { return *this ^ rhs ^ (*this & rhs); }

    Bit operator~() const {
        Bit ret;

        ret._share = _share;

        if (party() == 0) {
            ret._share ^= ot()->garbled_delta();
        }

        return ret;
    }

    Bit operator&&(const Bit &rhs) const {
        return *this & rhs;
    }

    Bit operator||(const Bit &rhs) const {
        return *this | rhs;
    }

    Bit operator!() const {
        return ~*this;
    }
    u8 lsb() const {
      u8 ret = block_lsb(_share);
      return ret & (u8)1;
    }

    bool reconstruct() const {
        u8 remote;
        u8 local = block_lsb(_share);

        if (party() == 0) {
            remote = net()->recv<u8>(next_party());
            net()->send(next_party(), local);
        } else {
            net()->send(next_party(), local);
            remote = net()->recv<u8>(next_party());
        }

        return remote ^ local;
    }

};

std::vector<bool> reconstruct(std::vector<Bit> bits,
              size_t party_in);

using Bool = Bit;

} // namespace privc

